/**
 * A function that finds the best move to take in a 3x3 tic tac toe game
 * @param {2D Array} board - The current state of the board
 * @param {String} currPlayer - The string representing the current player
 * @param {String} myPlayer - The string representing my player
 * @param {String} otherPlayer - The string representing the other player
 *
 * @returns {Object} - an object representing the ideal move to take
 */
function minimax(board, currPlayer, myPlayer, otherPlayer) {
  // get the empty spots
  var emptySpots = checkForEmptySpots(board, myPlayer, otherPlayer);

  // list of moves available to pick from
  var moves = [];
  var bestMove = null;

  // check if the current board is a winning state for any player
  if (isWinning(board, myPlayer)) {
    // when the move allow use to win
    return { score: 10 };
  } else if (isWinning(board, otherPlayer)) {
    // when the move will allow the other player to win
    return { score: -10 };
  } else if (emptySpots.length === 0) {
    return { score: 0 };
  }

  for (var i = 0; i < emptySpots.length; i++) {
    var row = emptySpots[i].row;
    var column = emptySpots[i].column;
    var move = {
      row: row,
      column: column,
      score: null
    };

    board[row][column] = currPlayer;

    if (currPlayer === myPlayer) {
      var result = minimax(board, otherPlayer, myPlayer, otherPlayer);
      move.score = result.score;
    } else if (currPlayer === otherPlayer) {
      var result = minimax(board, myPlayer, myPlayer, otherPlayer);
      move.score = result.score;
    }

    board[row][column] = 0;
    moves.push(move);
  }

  if (currPlayer === myPlayer) {
    var bestScore = -1000;
    for (var i = 0; i < moves.length; i++) {
      if (moves[i].score > bestScore) {
        bestScore = moves[i].score;
        bestMove = i;
      }
    }
  } else if (currPlayer === otherPlayer) {
    var bestScore = 1000;
    for (var i = 0; i < moves.length; i++) {
      if (moves[i].score < bestScore) {
        bestScore = moves[i].score;
        bestMove = i;
      }
    }
  }
  return moves[bestMove];
}

/**
 * A function to get all the empty position index from the current board
 *
 * @param {2D Array} board - The current state of the board
 * @returns {Array} - Array that contains an object with row and column
 */
function checkForEmptySpots(board, myPlayer, otherPlayer) {
  var emptySpots = [];
  for (var row = 0; row < board.length; row++) {
    for (var column = 0; column < board[row].length; column++) {
      var currentSpot = board[row][column];
      if (currentSpot !== myPlayer && currentSpot !== otherPlayer) {
        emptySpots.push({ row: row, column: column });
      }
    }
  }
  return emptySpots;
}

/**
 * A function to see if the player is winning
 *
 * @param {2D Array} board - The current state of the board
 * @param {String} player - A string representing the player's character
 */
function isWinning(board, player) {
  var winningState1 =
    board[0][0] === player && board[0][1] === player && board[0][2] === player;
  var winningState2 =
    board[1][0] === player && board[1][1] === player && board[1][2] === player;
  var winningState3 =
    board[2][0] === player && board[2][1] === player && board[2][2] === player;
  var winningState4 =
    board[0][0] === player && board[1][0] === player && board[2][0] === player;
  var winningState5 =
    board[0][1] === player && board[1][1] === player && board[2][1] === player;
  var winningState6 =
    board[0][2] === player && board[1][2] === player && board[2][2] === player;
  var winningState7 =
    board[0][2] === player && board[1][1] === player && board[2][0] === player;
  var winningState8 =
    board[0][0] === player && board[1][1] === player && board[2][2] === player;
  if (
    winningState1 ||
    winningState2 ||
    winningState3 ||
    winningState4 ||
    winningState5 ||
    winningState6 ||
    winningState7 ||
    winningState8
  ) {
    return true; // player won
  }
  return false; // does not match any winning state
}

module.exports = minimax;
